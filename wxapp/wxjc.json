{"zuozhe": "Rolan", "pp": "出现 JavaScript 异常可能导致小程序的交互无法进行下去，我们应当追求零异常，保证小程序的高鲁棒性和高可用性，相信这一点一般情况下都不会出现，需要注意的是代码测试中多场景的试错。2.合理控制图片的大小图片太大会增加下载时间和内存的消耗，应根据显示区域大小合理控制图片大小。 一般情况下图片较大的，我们应该都会选择直接放在服务器上，直接拿到地址，但是官方说这样读取的图片： 存在网络图片资源未开启 HTTP 缓存控制 ,这是个什么意思，我也未完全弄懂。3.小程序所有请求应响应正常请求失败可能导致小程序的交互无法进行下去，应当保证所有请求都能成功。然而，请求成功只是第一步，还可能存在的问题就是请求的耗时太长、存在短时间内发起太多的请求这样的情况，一方面是后台人员的接口写的烂，一方面就是需求使然（技术半吊子，还想安全的产品经理会有这种让你去指定地方请求的情况），比如在阿里云OSS存储的一些json数据。。。。4.避免setData的数据过大且避免setData的调用过于频繁。由于小程序运行逻辑线程与渲染线程之上，setData的调用会把数据从逻辑层传到渲染层，数据太大会增加通信时间. setData接口的调用涉及逻辑层与渲染层间的线程通过，通信过于频繁可能导致处理队列阻塞，界面渲染不及时而导致卡顿，应避免无用的频繁调用.5.避免将未绑定在 WXML 的变量传入 setDatasetData操作会引起框架处理一些渲染界面相关的工作，一个未绑定的变量意味着与界面渲染无关，传入setData会造成不必要的性能消耗。 这一条我想是很多开发人员在初次接触小程序开发的时候都会犯的一个错误吧。因为刚开始的时候由于这种setData的语法，让我们忘了还有全局变量的使用，于是会经常出现使用Page中定义的data做中间过渡。6.wxss 覆盖率较高，较少或没有引入未被使用的样式我们应该按需引入 wxss 资源，如果小程序中存在大量未使用的样式，会增加小程序包体积大小，从而在一定程度上影响加载速度。 这个也是比较常见的一种不规范，写了很多CSS样式，很多不用的就留来了代码里面，越来越多，所以在编写代码过程中，尽量去对每一行代码（特别是自己写的）了如指掌。7.避免首屏时间太长的情况首屏时间是指用户开始看到第一屏的内容的时间，首屏时间太长会导致用户长时间看到的都是白屏，会一直等待有意义的内容展示出来。出现这一情况，应仔细检查这个过程都有哪个操作，一般来说，可能是请求数据的时间太长，或者是一次渲染的数据太大导致渲染时间太长。这些东西是我感觉比较常见且容易修改的，其它还存在一些规范，不妨打开微信开发者工具，点击 Audits ,对你写的代码进行一个测试，测试结果会让你很好的处理自己的代码。That's really cool!", "title": "微信小程序开发需要注意的一些规范 ", "shijian": "2019-5-5 00:42"}
{"zuozhe": "Rolan", "pp": "小程序webview的现状\r\nh5页面在小程序中的交互（跳转）场景\r\n\r\nh5跳转小程序native页面（如：调用小程序地址选择能力，然后返回对应的地址信息给h5页面）\r\nh5跳转己方业务线的h5页面（内部页面交互，方式比较多样）\r\nh5跳转其它业务线的h5页面（如：交易流程，相关页面可能有其他业务线提供）\r\n\r\n主要痛点\r\n\r\n在完成相关操作后，页面状态需要更新，目前常见的更新方式有如下两种：\r\n\r\n第一种：通过url传参（如：url中加入__isonshowrefresh=1，告诉webview再次onshow时候刷新），把需要传递的参数拼接到url中，重新打开url。\r\n第二种：需要跳转到新的页面进行数据更新（如：下单页 - 地址选择页 - 新的下单页）\r\n\r\n\r\n第一种方案，功能上没有问题，但会导致页面刷新，如果页面操作复杂，需要多次刷新\r\n第二种方案，正向操作时体验比方案一好，但导致了另外一个问题：操作跳转层级过深，尤其返回的时候简直让人崩溃。\r\n\r\n小程序中，h5页面打开新页面方式\r\n我们先来看下小程序中常见的h5跳h5的方式：\r\n\r\n方式1：直接用location.href跳转，返回时候各机型表现不一致，有的会刷页面，重新执行js，有的会直接展示之前的缓存\r\n方式2：通过路由hash跳转，返回触发hashchange，页面不刷新，js层面重现渲染\r\n方式3：跳转页面打开一个新的webview，相当于每个页面都是一个独立的webview\r\n\r\n我们采用的是方式3，理由如下：\r\n\r\n打开新页面时的效果更趋近于native间的跳转（当然新打开的页面也会重新加载静态资源，同时这也有另一个问题，一旦你打开10个层级后，再打开新的webview就没反应了，这个是小程序10层限制）\r\n返回的体验也更趋近于native，同时保证页面状态统一（不会出现有的直接展示，有的会重新执行js）\r\nwebview通过this.src拿到的链接即为当前页面链接，因为如果页面自行通过路由和location.href跳转，页面链接变更后，webview并不会知晓，这种方案，webview通过this.src拿到的链接始终是当前页面的链接。\r\n\r\n\r\n由于这种方案可能会达到小程序的10层限制。所以在一些重要页面建议加入“回到首页”的操作，通过这个操作来缩短小程序历史栈\r\n\r\n回到首页方案简述\r\n（如果不感兴趣这部分可以直接略过）\r\nwx.miniProgram.reLaunch({\r\n  url: '/pages/webview/bridge?url=项目首页地址'\r\n})\r\n复制代码先声明，我们webview的路径是/pages/webview/webview\r\n/pages/webview/bridge是个中转页，有如下特点：\r\n\r\n该页面并不是最终打开h5页面的webview页，而是一个中转页。\r\n主要用作返回处理\r\n页面逻辑：\r\n\r\n如果是第一次展示，则跳转/pages/webview/webview，同时把url传过去，正常打开h5\r\n如果不是第一次展示，说明是从webview返回过来的，直接重定向到小程序首页\r\n\r\n\r\n\r\n这个中转页：主要保证reLaunch到某h5页面后，用户仍然可以点击返回到小程序首页。\r\n该方案通常用于：小程序中内嵌了多个业务线的h5页面这种场景。\r\n一个内容发布场景\r\n我们从首页进入发布页，完成发布后，跳转至商品详情页\r\n那么对于一个新用户来讲，整个操作过程是这样的：\r\n\r\n首页（点击发布）\r\n进入发布页面（选择发布商品的分类）\r\n进入商品分类页（选择完成后）\r\n将分类id拼入url，进入新的发布页面（选取件地址）\r\n进入地址列表页（如果新用户是没有地址的，点击新增地址）\r\n进入新增地址页（添加完成后）\r\n将地址id拼如url，进入又一个新的发布页面（编辑完信息后点击发布）\r\n进入发布成功页（点击查看商品详情）\r\n进入商品详情页\r\n\r\n这个场景就是同一个页面，里面不同的内容项需要跳转不同的页面去操作，然后再回到原来页面更新状态的问题。\r\n假如商品详情页没有“回到首页”的入口，那么这个用户要想回到首页。。。需要按8次“返回” = =！\r\n经过这个体验后，我想一般的用户是没有勇气再发布内容的。\r\n\r\n当然也有另一种这种折中方案\r\n\r\n就是商品提到的，在连接中加入某个标志位，比如在url中加入__isonshowrefresh=1，webview在打开连接时候，会去读取这个参数，如果有，则每次在onShow时候，重新加载url，通过刷新页面进行页面状态更新。\r\n这个体验也不爽，就是在复杂的页面会多次刷新。\r\n声明\r\n我下面要讲的这个方案并不是停留在设想阶段，它已经在线上跑了\r\n想看效果的朋友，可以在微信小程序中搜：\r\n“转转二手交易网”-“0元免费领”-(底部)“送闲置赚星星”-进入到发布页后\r\n\r\n\r\n分类（跳转h5，选中内容后返回，将参数传给之前的h5）\r\n\r\n\r\n取件地址（跳转native原生地址选择，选中后返回，将参数传给之前的h5）\r\n\r\n\r\nOK，我们进入今天的主题\r\n小程序中h5页面onShow和跨页面通信的实现\r\n首先想到的就是onShow方法的实现，之前有人提议用visibilitychange来实现onShow方法。\r\n但调研过后，这种方式在ios中表现符合预期，但是在安卓手机里，是不能按预期触发的。所以该方案被我否了。\r\n于是就有了下面的方案\r\n原理介绍\r\n这个方案需要h5和小程序的webview都做处理。\r\n核心思想：利用webview的hash特性\r\n\r\n\r\n小程序通过hash传参，页面不会更新（这个和浏览器一样）\r\nh5可以通过hashchange捕获最新参数，进行自定义逻辑处理\r\n最后执行window.history.go(-1)\r\n\r\n\r\n为什么要执行window.history.go(-1)\r\n\r\n这一步是整个方案的精髓：\r\n\r\n因为hash变更会导致webview历史栈长度+1，用户需要多一次返回操作。但这一步明显是多余的。\r\n同时window.history.go(-1)后，会把webview在hash中添加的参数去掉，还能保证和之前的url一致。\r\n\r\n方案延伸（跨页面数据传递）\r\n小程序里另个一常见的场景就是调用第三业务（或者己方业务），在做完某些操作后需要把选中的数据带回之前的页面。\r\n\r\n如前面提到的例子：发布页，需要选择发布类型，然后返回，发布页发布类型局部更新\r\n\r\n当然有些同学会说：我可以用setInterval，监控localStorage。在新页面选中内容后，设置localStorage，然后在返回不就可以了。\r\n我这里说的是通用方案。如果页面都是由己方业务线维护的当然可以随便折腾。\r\n但是一旦涉及到第三方业务线，尤其不同域名页面的业务调用，这种通信方式就尴尬了。\r\n那我的方案怎么处理呢，我总结了一张图\r\n\r\n我们来解读一下这张图：\r\n\r\nwebview1打开发布页面，h5绑定hashchange事件（因为webview通过hash传值时会触发该事件）\r\n将自定义的onShow方法缓存。在hashchange触发时，寻找指定参数，如果存在则触发\r\n用户点击跳转到类型选择页\r\n这时会打开一个新的webview2页面实例，打开类型选择页\r\n用户操作完成，调用wx.miniProgram.postMessage把数据发送给webview，并返回\r\nwebview由于绑定了bindmessage事件，在返回时会接收到h5发送的数据\r\n同时将接收到的数据缓存在一个全局的store中，webview2销毁，小程序执行返回\r\n从webview2返回到webview1，这时webview1的onShow钩子会触发\r\nwebview1读取全局的store，将要发送的参数取出，拼接h5链接的hash部分，并重新打开该链接\r\n虽然重新打开链接，由于仅仅是hash部分的变化，所以页面不会刷新\r\n但会触发h5页面的hashchange，此时调用用户自定义的onShow方法，读取hash参数，进行页面更新\r\nh5页面在执行完onShow方法后，调用window.history.go(-1)，恢复历史栈\r\n\r\n整个过程就是这样\r\n代码示意：\r\n小程序\r\n小程序webview要先做几方面考虑：\r\n\r\n出于平滑接入的考虑，不能上来搞一刀切，要保证现有页面再不做任何修改的情况下继续访问。\r\n新能力要通过额外参数区分，如：检测url中的query部分，带有__isonshowpro=1再进行通过hash方式传参。\r\n改造原有逻辑，让__isonshowpro=1时，hash处理逻辑优先级最高\r\n参数定义，在前面加入了两个下划线，目的是为了分区url中正常的参数\r\n\r\n小程序端webview.wpy\r\n<web-view wx:if=\"{{url}}\" src=\"{{url}}\" binderror=\"onError\" bindload=\"onLoaded\" bindmessage=\"onPostMessage\"></web-view>\r\n\r\n// 链接处理工具方法\r\nimport util from '@/lib/util';\r\n// 全局数据存储操作类\r\nimport routeParams from '@/lib/routeParams';\r\nconst urlReg = /^(https?\\:\\/\\/[^?#]+)(\\?[^#]*)?(#[^\\?&]+)?(.+)?$/;\r\nlet messageData = {};\r\n\r\nexport default class extends wepy.page {\r\n  data = {\r\n    // 页面展示次数\r\n    pageShowCount: 0,\r\n    // 页面url中query部分的参数对象\r\n    mQuery: {},\r\n    ...\r\n  }\r\n  \r\n  onShow(){\r\n    ++this.pageShowCount;\r\n    // 获取其他页面经过操作后，需要传递给h5的参数\r\n    let data = routeParams.getBackFromData() || {};\r\n    // webview页面状态更新\r\n    if(this.pageShowCount > 1 && this.mQuery.__isonshowpro && this.mQuery.__isonshowpro === '1' || data.refresh){\r\n      // 获取需要传递给h5页面的参数\r\n      let refreshParam = data.refreshParam;\r\n      ...\r\n      // 如果连接中带有需要处理onShow逻辑的参数（通过url的hash和h5交互，而不是刷页面）\r\n      if (this.pageShowCount > 1 && this.mQuery.__isonshowpro === '1') {\r\n        let [whole, mainUrl, queryStr, hashStr, hashQueryStr] = urlReg.exec(this.url);\r\n        // 在url的hash中加入新的参数\r\n        hashStr = (hashStr || '#').substring(1);\r\n        if (refreshParam) {\r\n          delete refreshParam.refresh;\r\n        }\r\n        const messageData = this.getNavigateMessageData();\r\n        // 将需要更新的参数传给页面hash\r\n        hashStr = util.addQuery(hashStr, Object.assign({\r\n          // onshow标志位\r\n          __isonshow: 1,\r\n          // wa主动触发hashchange标志位\r\n          // 其实目前通过__isonshow就可以判断是wa主动触发hashchange\r\n          // 设置该字段是为了明确功能，且以后扩展用\r\n          __wachangehash: 1,\r\n          // 时间戳刷新\r\n          __hashtimestamp: Date.now()\r\n        }, messageData, refreshParam));\r\n        this.url = mainUrl + queryStr + '#' + hashStr;\r\n        console.log('【webview-hashchange-url】', this.url);\r\n        // 这里要加个延迟，否则在webview返回到webview时，无法触发hashchange，应该是小程序bug\r\n        setTimeout(()=> {\r\n          this.$apply();\r\n        }, 50);\r\n      // 通过修改query参数，刷新webview\r\n      } else {\r\n        ...\r\n      }\r\n      ...\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 获取需要发送的消息数据\r\n   */\r\n  getNavigateMessageData(){\r\n    let rst = {};\r\n    for(let i in messageData){\r\n      /* message结构:\r\n        message: {\r\n          key: 'xx',        // 消息名称\r\n          content: 'xx',    // 消息内容\r\n          trigger: {        // 触发条件\r\n            type: '',       // 触发类型 \r\n                               - immediately 在下一次onshow或者打开页面中立刻触发，\r\n                               - url 在找到指定h5链接时触发\r\n            content: ''     // 条件内容\r\n                               - type=immediately 时为空\r\n                               - type=url 时候为h5链接地址\r\n          }\r\n        }\r\n      */\r\n      const message = messageData[i];\r\n      const trigger = message.trigger || {};\r\n      // 立刻发送、路径触发\r\n      if(trigger.type === 'immediately' || trigger.type === 'url' && this.url.indexOf(trigger.content) > -1){\r\n        // 将key和content集合到一个对象中，便于hash直接设置\r\n        rst[message.key] = message.content;\r\n        // 消息通知后，从缓存中删除\r\n        delete messageData[message.key];\r\n      }\r\n    }\r\n    console.log('【webview-get-message】', rst);\r\n    console.log('【webview-message-cache】', messageData);\r\n    return rst;\r\n  }\r\n  \r\n  /**\r\n   * 存储消息数据\r\n   */\r\n  storeNavigateMessageData(message){\r\n    if(message && message.key){\r\n      console.log('【webview-store-message】', message)\r\n      // 通过key设置每一条消息名称\r\n      messageData[message.key] = message;\r\n      console.log('【webview-message-cache】', messageData);\r\n    }\r\n  }\r\n  \r\n  methods = {\r\n    // 接收发送过来的消息\r\n    onPostMessage(e){\r\n      if(!e.detail.data)return;\r\n      const detailData = e.detail.data;\r\n      // 获取消息数据\r\n      let messageData = getValueFromMixedArray(detailData, 'messageData', true);\r\n      if (messageData) {\r\n        // 存储\r\n        this.storeNavigateMessageData(messageData);\r\n      }\r\n      ...\r\n    }\r\n  }\r\n  \r\n  ...\r\n}\r\n复制代码上面东西看着挺多，总结下来就是几点：\r\n\r\n 绑定bindmessage事件\r\n接收到页面传来的消息之后，需要按照一定规则存起来（我是按照key存储的）\r\nwebview在触发onShow钩子时候，按照之前传过来的触发条件（condition），取出需要发送的消息数据\r\n将数据拼接到url的hash部分，并加入特有的标志位，重新加载url\r\n\r\nh5端\r\nh5端在做修改时也要考虑几点：\r\n\r\n\r\n最好能把这些交互逻辑封装起来\r\n\r\n\r\n让业务方比较简单方便的调用\r\n\r\n\r\n这里我新定义了2个方法\r\n\r\nonShow(callback)\r\n\r\n描述：这个和小程序onShow钩子一样，只不过是给h5调用的\r\n参数：callback 回调方法\r\n\r\n\r\n\r\n例子：发布页面，需要选择分类，返回时需要更新分类信息\r\nimport { isZZWA, onShow } from '@/lib/sdk'\r\nimport URL from '@/lib/url'\r\n\r\n...\r\ncreated () {\r\nif (isZZWA()) {\r\n  onShow(() => {\r\n  // 地址信息\r\n    const addressInfo = URL.getHashParam('zzwaAddress')\r\n      console.log('addressInfo:', decodeURIComponent(addressInfo))\r\n      ...\r\n      // 分类信息\r\n      const selecteCateInfo = URL.getHashParam('selecteCateInfo')\r\n      console.log('selecteCateInfo:', selecteCateInfo)\r\n      ...\r\n  } else {\r\n    ...\r\n  }\r\n}\r\n...\r\n复制代码\r\nserviceDone(data, condition)\r\n\r\n描述：业务结束，需要将数据传递给指定页面\r\n参数：\r\n\r\ndata Object 需要传递的数据 {key: 'xx', content: 'xx'}\r\ncondition String|Number 触发条件\r\n\r\nString 指定url的路径，当webview打开指定的url触发onshow时，会发送该消息\r\nNumber 返回到指定的测试，类似history.go(-1)，如： -1，-2\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n例子：类型选择页\r\nimport { isZZWA, serviceDone } from '@/lib/sdk'\r\n// 类型选择点击\r\ntypeChooseClick (param, type) {\r\n  ...\r\n  if (isZZWA()) {\r\n    // 需要返回的数据\r\n    const data = {\r\n      key: 'selecteCateInfo',\r\n      content: JSON.stringify({...})\r\n    }\r\n    // 通过postMessage发送给小程序，-1表示返回上一页面\r\n    serviceDone(data, -1)\r\n  } else {\r\n    ...\r\n  }  \r\n}\r\n复制代码\r\n\r\nok，我们来看看h5端的sdk是怎么实现的\r\nimport util from './util';\r\n\r\nclass WASDK {\r\n  /**\r\n   * Create a instance.\r\n   * @ignore\r\n   */\r\n  constructor(){\r\n    // hashchang事件处理\r\n    if('onhashchange' in window && window.addEventListener && !WASDK.hashInfo.isInit){\r\n      // 更新标志位\r\n      WASDK.hashInfo.isInit = true;\r\n      // 绑定hashchange\r\n      window.addEventListener('hashchange', ()=>{\r\n        // 如果小程序webview修改的hash，才进行处理\r\n        if (util.getHash(window.location.href, '__wachangehash') === '1') {\r\n          // 这块有个坑：\r\n          // ios小程序webview在修改完url的hash之后，页面hashchange和更新都可以正常触发\r\n          // 但是：h5调用部分小程序能力会失败(如：ios在设置完hash后，调用wx.uploadImg会失败，需要重新设置wx.config)\r\n          // 因为ios小程序的逻辑是，url只要发生变化，wx.config中的appId就找不到了\r\n          // 所以需要重新进行wx.config配置\r\n          // 这一步是获取之前设置wx.config的参数（需要从服务端拿，因为之前已经获取过了，这里从缓存直接取）\r\n          const jsticket = window.native && window.native.adapter && window.native.adapter.jsticket || null;\r\n          const ua = navigator.userAgent;\r\n          // 非安卓系统要重新设置wx.config\r\n          if (jsticket && !(ua.indexOf('Android') > -1 || ua.indexOf('Adr') > -1)) {\r\n            window.wx.config({\r\n              debug: false,\r\n              appId: jsticket.appId,\r\n              timestamp: jsticket.timestamp,\r\n              nonceStr: jsticket.noncestr,\r\n              signature: jsticket.signature,\r\n              jsApiList: ['onMenuShareTimeline', 'onMenuShareAppMessage', 'onMenuShareQQ',\r\n                'onMenuShareQZone', 'onMenuShareWeibo', 'scanQRCode', 'chooseImage', 'uploadImage', 'previewImage', 'getLocation', 'openLocation']\r\n            })\r\n          }\r\n          // 触发缓存数组的回调\r\n          WASDK.hashInfo.callbackArr.forEach(callback=>{\r\n            callback();\r\n          })\r\n          // 执行返回操作（这一步是重点！！）\r\n          // 因为webview设置完hash参数后，会使webview历史栈+1\r\n          // 而实际并不需要这次多余的历史记录，所以需要执行返回操作把它去掉\r\n          // 即便是返回操作，也仅仅是hash层面的变更，所以不会触发页面刷新\r\n          // 用setTimeout表示在下一次事件循环进行返回操作。如果后面有对dom操作可以在当前次事件循环完成\r\n          setTimeout(()=>{\r\n            window.history.go(-1);\r\n          }, 0);\r\n        }\r\n      }, false)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * hash相关信息\r\n   */\r\n  static hashInfo = {\r\n    // 是否已经初始化\r\n    isInit: false,\r\n    // hash回调香瓜数组\r\n    callbackArr: []\r\n  }\r\n  \r\n  /**\r\n   * 页面再次展示时钩子方法\r\n   * @param {Function} callback - 必填, callback回调方法, 回传参数为hash部分问号后面的参数解析对象\r\n   */\r\n  @execLog\r\n  onShow(callback){\r\n    if (typeof callback === 'function') {\r\n      // 对回调方法进行onshow逻辑包装，并推入缓存数组\r\n      WASDK.hashInfo.callbackArr.push(function(){\r\n        // 检查是否是指定参数发生变化\r\n        if(util.getHash(window.location.href, '__isonshow') === '1'){\r\n          // 触发onShow回调\r\n          callback();\r\n        }\r\n      })\r\n    } else {\r\n      util.console.error(`参数错误，调用onShow请传入正确callback回调`);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 业务处理完成并发送消息\r\n   * @param {Object}           obj - 必填项，消息对象\r\n   * @param {String}           obj.key - 必填项，消息名称\r\n   * @param {String}           obj.content - 可选项，消息内容，默认空串，如果是内容对象，请转换成字符串\r\n   * @param {String|Number}    condition - 可选项，默认仅进行postMessage\r\n   *                              String - 可以传指定url的路径，当小程序webview打开指定的url或者onshow时，会触发该消息\r\n   *                                       也可传小程序path，这个为以后预留\r\n   *                              Number - 返回到指定的测试，类似history.go(-1)，如： -1，-2\r\n   */\r\n  @execLog\r\n  serviceDone(obj, condition){\r\n    if(obj && obj.key){\r\n      // 消息体\r\n      const message = {\r\n        // 消息名称\r\n        key: obj.key,\r\n        // 消息体\r\n        content: obj.content || '',\r\n        // 触发条件\r\n        trigger: {\r\n          // 类型 'immediately'在下一次onshow中立刻触发， 'url'，在找到指定h5链接时触发，'path'在打开指定小程序路径时触发\r\n          type: 'immediately',\r\n          // 条件内容，immediately是为空，url是为h5链接地址，path是为小程序路径\r\n          content: ''\r\n        }\r\n      };\r\n      // 解析触发条件\r\n      condition = condition || 0;\r\n      // 如果是路径\r\n      if(typeof condition === 'string' && (condition.indexOf('http') > -1 || condition.indexOf('pages/') > -1)){\r\n        // 设置消息触发条件\r\n        message.trigger = {\r\n          type: condition.indexOf('http') > -1 ? 'url' : 'path',\r\n          content: condition\r\n        }\r\n      }\r\n      // 发送消息\r\n      wx.miniProgram.postMessage({\r\n        data: {\r\n          messageData: message\r\n        }\r\n      });\r\n      // 如果不是url或者path触发，则对conditon是否需要返回进行判断\r\n      if(message.trigger.type === 'immediately'){\r\n        // 查看是否需要返回指定的层级，兼容传入'-1'字符串这种类型的场景\r\n        try{\r\n          condition = parseInt(condition, 10);\r\n        }catch(e){}\r\n        // 保证返回级数的正确性\r\n        if(condition && typeof condition === 'number' && !isNaN(condition)){\r\n          this.handler.navigateBack({delta: Math.abs(condition)});\r\n        }\r\n      }\r\n    }else{\r\n      util.console.error(`参数错误，调用serviceDone方法，传入的对象中不包含key值`);\r\n    }\r\n  }\r\n  \r\n  ...\r\n}\r\n\r\nwindow.native = new Native();\r\n\r\nexport default native;\r\n\r\n复制代码这个看着也挺多，总结下来是两点：\r\n\r\nonShow方法的实现\r\n\r\n绑定一个hashchange事件（这里做了防止重复绑定事件的处理）\r\n将传入的onShow自定义事件缓存在一个数组中，hashchange触发时，根据特有的标志位__isonshow和__wachangehash确定是否触发\r\n\r\n\r\nserviceDone方法的实现\r\n\r\n处理传过来的数据\r\n处理该数据的触发条件：immediately表示最近的一次onShow触发，或者自己指定url\r\n通过wx.miniProgram.postMessage发送数据\r\n\r\n\r\n\r\nok，整个方案就介绍完了\r\n结语\r\n最早的方案并不完全是这样的，但原理是一样的。在我实现的过程中发现原始方案有很多问题\r\n于是我又做了大量的改造和细节优化，于是形成了上面的最终方案。\r\n这个方案属于侵入式改造方案，需要各业务方改造自己的代码。虽然有一定改造成本，但用户体验的收益非常明显。\r\nps：我们的QA在测试时都说“这用起来就爽多了”\r\n注意：\r\n采用这个方案需要注意几点：\r\n\r\n如果采用这种方式通信，需要在当前页面url的query部分加入__isonshowpro=1，否则是不会通过hash通信的\r\n同时要保证页面确实调用了onShow方法，否则页面也是不会刷新的\r\n如果第三方业务需要传值，需要统一采用serviceDone方法通信\r\n\r\n好了，今天就介绍这么多，大家一起学习", "title": "小程序中h5页面onShow实现及跨页面通信方案 ", "shijian": "2019-5-30 00:48"}
{"zuozhe": "Rolan", "pp": "上周，微信开放社区公布了小程序名称规则调整的公告，主要是针对之前一些投机的取名做法罗列了调整和优化建议，调整后的命名规范比之前更加严格。小程序的价值在于提供服务，平台也是希望小程序名称等的信息能够具有准确性和独特性，减少误导、混淆用户理解的可能性。这些调整规范也可以总结为“五不一建议”：01 不得使用违反广告法等禁止的用语Eg. 国家级、世界级、最高级、最佳、第一、唯一、首个、最好、精确、顶级、最低、最底、最便宜、最大程度、最新技术、最先进科学、国家级产品、填补国内空白、绝对、独家、首家、最新、最先进、第一品牌、金牌、名牌、最赚、超赚、最先、巨星、奢侈、至尊、顶级享受02 不得使用营销味重的商业化用语Eg. 免费、促销、清仓、打折、免单广告法禁用语和商业化用语往往自带夸大的表达效果，会对用户产生误导。03 不得混用热门公众号、小程序或第三方品牌名称蹭热门应用、小程序或第三方知名品牌名称一直是某些小程序增加曝光的途径，这也会导致用户用错小程序，带来时间和精力上的浪费。在新的规则规范下，这类做法将被禁止，除非已获授权。04 不建议使用广义归纳类的词汇直接使用这类词汇，缺乏显著性，也会给用户带来无法识别、区分小程序的困扰。05 不建议使用关键词堆砌过于冗长的关键词堆砌名称是为了能够在搜索结果上获得更多的曝光，但这并不利于品牌记忆的建立以及用户的理解。应对方法：可将小程序有关的关键词放入功能介绍，达到关键词搜索优化的目的。06 建议在名称信息上包含品牌信息这种名称具有辨识度，也便于用户识别。小程序正确的名称公式：品牌+产品类别名/产品名这些调整从表面看是为了提升用户体验，那对开发者而言，这么严格的规范究竟是好还是坏呢？命名审核虽然在短期会给开发者造成一定的麻烦，但从长期看来，这是保障开发者权益的举措。以小游戏为例，开发者辛苦打造了一个爆款出来，结果被抄袭又名称相似的小游戏瓜分了流量。但现在在这个命名规范的限制下，以下情况将会大大减少。同时，开发者通过现有的小程序与用户建立了品牌偏好，在新的小程序推出时能够形成小程序矩阵，也可以降低宣传成本。微信平台这次调整，其实是在强调“品牌”，目的是让用户通过使用小程序，接受并建立对开发者产品品牌的认知，这样也有利于开发者产品的长远发展。特别注意对于调整规范发布前已经通过审核的小程序，开发者也不要掉以轻心，近期平台可能将对名称重新审核，所以请提前自查，做好准备。", "title": "小程序命名规范大调整，现在不能这样取名了 ", "shijian": "2019-5-30 00:56"}
{"zuozhe": "Rolan", "pp": "我们在写小程序的时候，手机端预览的发现获取不到数据，只能是用真机调试才可以，可以mac端的开发者工具对于真机调试的体验苦不堪言，各种bug（官方bug）。所以我想有没有什么办法直接使用预览也可以一样获取到数据呢。花了一天的时间，终于是成功了。我室友预览的时候一样可也以有数据。\r\n关键点：\r\n手机，服务器，保持同一局域网。\r\n第一步：开启局域网\r\n方法1）使用电脑开启共享wifi，手机连接此wifi。不过这里因为我们学校内部网需要账号登陆，所以我没采用这种方法，不过这种方法的后续流程和第二种方法差不多。\r\n方法2）手机开启热点，电脑连接此热点。\r\n1）连接后，首先找到分配给电脑的IP。mac获取IP在设置->网络，里面就可以看到。\r\n\r\n或者在终端输入ifconfig，可以找到\r\n\r\n第二步：修改服务器地址\r\n我后台使用的SpringBoot，在properties里面直接修改\r\n\r\n第三步：修改url地址：\r\n之前使用的url地址类似于：http://localhost:8080/user/login/\r\n修改后服务器地址后同一修改为：http://172.20.10.2:8080/user/login/\r\n重启后台，然后在postman测试一下：\r\n\r\nok，可以获取到数据。\r\n然后我们把小程序里的request里的url全部使用这种方法。\r\n\r\n重新编译后，测试一下可不可以获取到数据，如果之前步骤没错，肯定没问题的。\r\n我们直接使用预览，也是一样可以获取到数据的。\r\n注意点：\r\n1） 在后台修改了地址后，以后必须在热点环境下运行项目，不然会报错。（我就是有一次忘记连热点，结果一直启动失败，我还以为是8080端口占用问题）\r\n2）如果要别人预览你的小程序，得先连接你的热点，才能获取到数据。\r\n总结：\r\n对了，如果你还有了网页，那么一样可以使用这种方法在手机上访问你的界面的。\r\n小程序截图：\r\n\r\n网页手机截图：", "title": "微信小程序预览也可以获取数据的 ", "shijian": "2019-5-31 00:11"}
{"zuozhe": "Rolan", "pp": "在最开始准备制作小程序的时候，为了求开发的快速，所使用了直接page的引入方式，每次小程序加载都是全包下载。3月份之前小程序页面稳定在35个，下载耗时在1800ms左右，4月份初上线了新业务页面膨胀到52个页面时，下载耗时基本稳定在2300ms左右，随着用户反馈越来越多，所以开始准备小程序采用分包加载，来解决这个问题。5月份在分包加载之后，页面依旧稳定在52个，但是下载耗时稳定800ms左右，缩短了将近1500ms。基本做到了0业务入侵、加入npm script 来实现新建页面，同时兼容分包加载，page加载。操作流程执行命令npm run new\r\n复制代码弹出单选，并且输入路径[Info] 帮助你快速创建page文件\r\n[Info] 只局限于新目录创建\r\n[Info] 请输入文件路径，已帮你省略pages/\r\n[Info] 例子：address/addressList\r\n? 请输入文件路径：\r\n复制代码输入路径之后创建文件的提示[Info] 已创建base64.js\r\n[Info] 已创建index.js\r\n[Info] 已创建index.json\r\n[Info] 已创建index.wxml\r\n[Info] 已创建index.wxss\r\n[Info] 创建完成！！！！\r\n复制代码选择包，是主包、还是分包，并且提示，如果是tabBar中使用，只能选择主包，并且手动配置app.json的tabBar? 你想生成什么样的包： (Use arrow keys)\r\n❯ 主包，在pages中写入，如果是tabBar中使用，只能选择主包，并且手动配置app.json的tabBar\r\n  分包，在subpackages中写入\r\n复制代码单选完成之后提示新建成功[Info] 写入成功\r\n复制代码第一次分包首先我们对未分包和分包的app.json代码进行对比// 未分包\r\n\"pages\": [\r\n  \"pages/a/index\",\r\n  \"pages/b/index\",\r\n  \"pages/b/list\",\r\n]\r\n复制代码// 实现分包\r\n\"subpackages\": [\r\n  {\r\n    \"root\": \"pages/a\",\r\n    \"pages\": [\r\n      \"index\",\r\n    ]\r\n  },\r\n  {\r\n    \"root\": \"pages/b\",\r\n    \"pages\": [\r\n      \"index\",\r\n      \"list\"\r\n    ]\r\n  }\r\n]\r\n复制代码接下来看目录结构pages\r\n  |---- a\r\n        |---- index.js\r\n  |---- b\r\n        |---- index.js\r\n        |---- list.js\r\napp.json\r\n复制代码简单分一下，第一次分包的核心业务是，将pages这个普通列表，变成名为subpackages的二叉树状态结构，左子节点是root，右子节点是pages，并且右子节点是string类型，左子节点是array类型。好吧，我可以定下规则，首先我可以将 pages/a/index 这个字符串变为数组以 / 为分界的 ['pages','a','index'] 数组，然后我将前两项作为root节点的参数，用slice操作截取出来，转为字符串类型，赋值给root。之后的所有参数，我都赋值或者push给pages参数，最后我就得到了这样一个符合要求的树，最后push进subpackages即可。至于数据源，我只需要读出app.json这个文件的pages参数，并且通过我的方法写入subpackages参数即可。要点去重，因为subpackages内，root节点是唯一的，但是在pages里面可能我会截取初重复的值解决使用Map结构，把截取出的root值作为key，剩下的作为value，Map数据这种数据结构的特点就是key值唯一。let list = [\r\n  \"pages/a/index\",\r\n  \"pages/a/list\",\r\n  \"pages/a/detail/index\",\r\n  \"pages/c/list\",\r\n  \"pages/b/index\",\r\n];\r\n\r\nlet m = new Map();\r\nlet packages = [];\r\nlist.forEach(v=>{\r\n  let arr = v.split('/');\r\n  let root = arr.splice(0,2).join('/');\r\n  let pages = arr.join('/');\r\n\r\n  if(m.get(root)){\r\n    let s = m.get(root);\r\n    m.set(root,[...s, pages]);\r\n  }else{\r\n    m.set(root,[pages]);\r\n  };\r\n});\r\nfor(let [key,value] of m){\r\n  packages.push({\r\n    root: key,\r\n    pages: value,\r\n  })\r\n}\r\n\r\nconsole.log(packages);\r\n复制代码// log 出的结构\r\n[\r\n  { root: 'pages/a', pages: [ 'index', 'list', 'detail/index' ] },\r\n  { root: 'pages/c', pages: [ 'list' ] },\r\n  { root: 'pages/b', pages: [ 'index' ] }\r\n]\r\n复制代码我已经在不入侵业务的情况下实现了小程序的第一次分包，节约了我手动去改的劳动力，我个人认为，解决问题，上策用数据结构，中策写兼容代码，下策手动去改。至于，读出写入文件，我就不赘述了，google即可。创建pages的指令编写好吧，我实现了第一次的分包。然后我要思考，如果我每次要加页面的话，是不是就要去查看subpackages，找到对应的root，并且添加pages。这么重复劳动力的操作，我为什么不用脚本替代呢，是吧。核心需求编写交互式的命令输入检测输入的page是否存在不存在创建page目录，复制template根据用户选择，选择写入pages，或者写入subpackages在page文件加中预留componet文件夹，用做业务拆分，不加检测page是否存在的方法引入静态文件，保存pages级别的目录，也不被检测设计npm script{\r\n  \"subcontract\": \"node ./config/subcontract\",\r\n  \"new\": \"node ./config/new\"\r\n}  \r\n复制代码添加的package.json参数{\r\n  \"ignore-files\": [\r\n    \"**/common/**\",\r\n    \"**/component/**\",\r\n    \"<name>/**\",\r\n    \"<name>/**\",\r\n    \"<name>/**\",\r\n  ],\r\n  \"pages\": [\r\n    \"pages/<name>/index\",\r\n    \"pages/<name>/index\",\r\n    \"pages/<name>/index\",\r\n  ]\r\n}\r\n复制代码需求已经明确，我就要去找我需要用到的npm包了colors        命令行颜色\r\ninquirer      交互式命令行\r\nglob          全局搜索文件\r\nfs-extra      文件写入写出\r\npath          路径\r\nshelljs       执行shell命令\r\n复制代码分析 new.js 文件const colors = require('colors');\r\nconst inquirer = require('inquirer');\r\nconst glob = require('glob');\r\nconst fs = require('fs-extra');\r\nconst path = require('path');\r\nconst shell = require('shelljs');\r\nconst PKG = require('../package.json');\r\nconst ROOT = path.resolve(__dirname, '../');\r\n\r\nlet appJson = require('../app.json');\r\nconst promps = [{\r\n  type: 'input',\r\n  name: 'pagePath',\r\n  message: '请输入文件路径：',\r\n},\r\n{\r\n  type: 'list',\r\n  name: 'type',\r\n  message: '你想生成什么样的包：',\r\n  choices: [\r\n    {\r\n      name: '主包，在pages中写入，如果是tabBar中使用，只能选择主包，并且手动配置app.json的tabBar',\r\n      value: '1',\r\n    },\r\n    {\r\n      name: '分包，在subpackages中写入',\r\n      value: '2',\r\n    },\r\n  ],\r\n}];\r\nconst logger = {\r\n  info(msg) {\r\n    console.log(`[Info] ${colors.green(msg)}`);\r\n  },\r\n  warn(msg) {\r\n    console.log(`[Warn] ${colors.yellow(msg)}`);\r\n  },\r\n  error(msg) {\r\n    console.log(`[Error] ${colors.red(msg)}(／‵Д′)／~ ╧╧`);\r\n  },\r\n};\r\n\r\nlogger.info('帮助你快速创建page文件');\r\nlogger.info('只局限于新目录创建');\r\nlogger.info('请输入文件路径，已帮你省略pages/');\r\nlogger.info('例子：xxxxx/xxxx');\r\n复制代码这是代码中的常量部分和默认提示部分，我写了logeer对象来作为提示输出的默认颜色，promps作为我交互命令行的基础配置。引入package.json我的主要目的是因为我屏蔽了一些文件 ignore-files 和 pages ，想这两个参数的文件夹我是不会检测的。function checkFile(name) {\r\n  const options = {\r\n    ignore: [\r\n      '**/*.js',\r\n      '**/*.wxss',\r\n      '**/*.wxml',\r\n      '**/*.json',\r\n    ],\r\n    cwd: 'pages/',\r\n  };\r\n  const files = glob.sync('**', options);\r\n  if (files.some((v) => v === name)) {\r\n    logger.error('输入的目录已经存在，已终止！！！！');\r\n    return false;\r\n  };\r\n  return name;\r\n};\r\n复制代码检查文件夹是否存在这是检测文件是否存在的方法，我只需要得到路径，即可检测这个路径是否在目录中存在。function buildFile(name) {\r\n  const options = {\r\n    cwd: 'template/page',\r\n  };\r\n  const files = glob.sync(`**`, options);\r\n\r\n  files.forEach((v)=>{\r\n    const file = v.split('.tp')[0];\r\n    fs.copy(`${ROOT}/template/page/${v}`, `${ROOT}/pages/${name}/${file}`, (err) => {\r\n      if (err) {\r\n        console.error(err);\r\n        return false;\r\n      }\r\n    });\r\n    logger.info(`已创建${file}`);\r\n  });\r\n  logger.info('创建完成！！！！');\r\n  return true;\r\n};\r\n复制代码这是复制文件夹并且复制模版文件的方法，我准备了tempalte这个文件夹，用来存储我写的模版文件，创建完成之后，我直接复制进去即可function subcontract(res) {\r\n  inquirer.prompt(promps[1]).then((answers)=>{\r\n    if (answers.type === '1') {\r\n      PKG['ignore-files'].push(`${res}/**`);\r\n      PKG['pages'].push(`${res}/index`);\r\n      appJson['pages'].push(`pages/${res}/index`);\r\n      fs.writeFileSync(`${ROOT}/app.json`, JSON.stringify(appJson, null, 2));\r\n      fs.writeFileSync(`${ROOT}/package.json`, JSON.stringify(PKG, null, 2));\r\n      logger.info('写入成功');\r\n    };\r\n    if (answers.type === '2') shell.exec('npm run subcontract');\r\n  });\r\n};\r\n复制代码这是选择pages还是subcontract的方法，选择了subcontract，我直接执行我上面写的小程序分包方法 subcontract.js 即可。如果选择pages，我会将它加入package.json中的 ignore-files对象，这个对象表式这些文件名不被subcontract脚本检测。async function inquirers() {\r\n  const {pagePath} = await inquirer.prompt(promps[0]);\r\n  const path = pagePath.replace(/\\s+/g, '');\r\n\r\n  if (!path) {\r\n    logger.error('输入有失误，已终止！！！！');\r\n    return false;\r\n  };\r\n  if (/.*[\\u4e00-\\u9fa5]+.*$/.test(path)) {\r\n    logger.error('请不要输入中文符号，已终止！！！！');\r\n    return false;\r\n  };\r\n\r\n  return path;\r\n};\r\n复制代码检测输入值是否合法，并且去除空格( async function() {\r\n  const inquirerRes = await inquirers();\r\n  const checkFileRes = inquirerRes && checkFile(inquirerRes);\r\n  const buildFileRes = checkFileRes && buildFile(checkFileRes);\r\n  buildFileRes && subcontract(checkFileRes);\r\n})();\r\n复制代码最后组装，inquirerRes变量负责判断输入值是否正确。然后进入checkFile，来检测文件夹是否重复。调用buildFile方法，创建文件夹，复制模版文件。最后调用subcontract来判断是分包还是主包。subcontract.js 分析const glob = require('glob');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst colors = require('colors');\r\nconst ROOT = path.resolve(__dirname, '../');\r\nconst PAG = require('../package.json');\r\nlet appJson = require('../app.json');\r\n\r\nconst ignoreFiles = PAG['ignore-files'];\r\nconst pages = PAG['pages'];\r\nconst logger = {\r\n  info(msg) {\r\n    console.log(`[Info] ${colors.green(msg)}`);\r\n  },\r\n  warn(msg) {\r\n    console.log(`[Warn] ${colors.yellow(msg)}`);\r\n  },\r\n  error(msg) {\r\n    console.log(`[Error] ${colors.red(msg)}(／‵Д′)／~ ╧╧`);\r\n  },\r\n};\r\n\r\nconst subcontract = () => {\r\n  const options = {\r\n    ignore: ignoreFiles,\r\n    cwd: 'pages/',\r\n  };\r\n  const files = glob.sync('**/index.js', options);\r\n\r\n  let subcontractMap = new Map();\r\n  files.forEach((v)=>{\r\n    let arr = v.split('.')[0].split('/');\r\n    let root = arr.shift();\r\n    let page = arr.join('/');\r\n\r\n    if (subcontractMap.has(root)) {\r\n      let pages = subcontractMap.get(root);\r\n      pages.push(page);\r\n      subcontractMap.set(root, pages);\r\n    } else {\r\n      subcontractMap.set(root, [page]);\r\n    }\r\n  });\r\n\r\n  let subcontractList = [];\r\n  subcontractMap.forEach((v, k)=>{\r\n    subcontractList.push({\r\n      root: `pages/${k}`,\r\n      pages: v,\r\n    });\r\n  });\r\n\r\n  return subcontractList;\r\n};\r\n\r\nappJson.subpackages = subcontract();\r\nappJson.pages = pages;\r\nfs.writeFileSync(`${ROOT}/app.json`, JSON.stringify(appJson, null, 2));\r\nlogger.info('写入成功');\r\n复制代码这个方法其实和小程序第一次分包的方法大同小异。只不过我修改了数据源的获取，第一次我是读取app.json的pages，这里我是根据目录来的，以及加入了ignoreFiles来做文件屏蔽。以及一些友好提示。结尾项目优化的道路还有很长这只是最最初步的方案。为什么我开始不直接选择分包呢？因为项目开始的时候还没有分包，而且如果有，我感觉分包机制可能会带给开发者出错的可能性，我为了将项目工期缩短，出错可能性降低，我也不会选择一开始就分包。当业务增长到一定量，以及业务逐渐趋向于稳定时候，我就可以根据业务的特性，去做相对应的事情。这种方式我称之为技术迭代。在何时的时候，选择何时的业务，坚决不过度设计。到此为止，其实我最想输出的是思路。我关于上中下，三策的理解，我对业务的理解。谢谢。", "title": "如果将老项目的小程序快速改为分包模式 ", "shijian": "2019-5-31 00:22"}
{"zuozhe": "Rolan", "pp": "需要解决的问题近几日一直在看怎样制作微信小程序的swiper轮播图。因为我既需要生成小程序的代码，也需要生成H5版代码，如果编写两套效率会比较低下，所以选择了 uni-app 。uni-app 已经在基础组件 swiper 中已经直接支持了轮播动画。我主要需要解决的是以下几个问题：animate.css\r\nswiper-item\r\n以下就是我整个制作的思路过程，仅供参考。另外，代码是 uni-app 开发，所以在小程序中和H5中测试都没有问题。另外为了方便 小程序 开发同学了解，会提供 小程序 版代码和 uni-app代码供参考。代码实现在H5开发中经常使用的就是 animate.css 。在微信中自然是支持的，因为微信会对上传的小程序有大小限制，所以这里我使用了一个极简化的 animate.css ，其中删掉了很多 -webkit-animation 开头的css3。因为我们只需要在小程序和H5中运行，这样做影响也不大。如果需要的话，可以从下面的代码中获取。我们先来看下代码：<template>\r\n    <view class=\"content\">\r\n        <button type=\"primary\" @tap=\"goChange\">跳转到第二屏</button>\r\n        <swiper class=\"content-swiper\" :vertical=\"true\" :indicator-dots=\"true\" :autoplay=\"false\" :interval=\"3000\" :duration=\"1000\" @change=\"changeSwiper\" @animationfinish=\"changeFinish\" :current-item-id=\"item_id\" circular=\"true\">\r\n            <swiper-item item-id=\"slide0\">\r\n                <view class=\"swiper-item\">\r\n                    <image src=\"../../static/uni.png\" :class=\"animate_0\"></image>\r\n                </view>\r\n            </swiper-item>\r\n            <swiper-item item-id=\"slide1\">\r\n                <view class=\"swiper-item\">\r\n                    <image src=\"../../static/uni.png\" :class=\"animate_1\"></image>\r\n                </view>\r\n            </swiper-item>\r\n            <swiper-item item-id=\"slide2\">\r\n                <view class=\"swiper-item\">\r\n                    <image src=\"../../static/uni.png\" :class=\"animate_2\"></image>\r\n                </view>\r\n            </swiper-item>\r\n            <swiper-item item-id=\"slide3\">\r\n                <view class=\"swiper-item\">\r\n                    <image src=\"../../static/uni.png\" :class=\"animate_3\"></image>\r\n                </view>\r\n            </swiper-item>\r\n        </swiper>\r\n    </view>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                item_id: 'slide2',\r\n                animate_0: 'animated swing',\r\n                animate_1: '',\r\n                animate_2: '',\r\n                animate_3: ''\r\n            }\r\n        },\r\n        onLoad() {\r\n\r\n        },\r\n        methods: {\r\n            changeSwiper(event){    // 清空除了当前swiper以外的所有动画\r\n                let current = event.detail.current;    // 当前页下标\r\n                this.item_id = 'slide'+current;     // 这里必须记录，否则只能跳转一次\r\n                switch (current){\r\n                    case 0:\r\n                        this['animate_1'] = this['animate_2'] = this['animate_3'] = '';\r\n                    break;\r\n                    case 1: \r\n                        this['animate_0'] = this['animate_2'] = this['animate_3'] = ''; \r\n                    break;\r\n                    case 2:\r\n                        this['animate_0'] = this['animate_1'] = this['animate_3'] = '';\r\n                    break;\r\n                    case 3:\r\n                        this['animate_0'] = this['animate_1'] = this['animate_2'] = '';\r\n                    break;\r\n                }\r\n\r\n            },\r\n            changeFinish(event){ // swiper动画完成之后，给当前swiper添加动画效果\r\n                let current = event.detail.current;\r\n                switch(current){\r\n                    case 0: \r\n                        this['animate_0'] = 'animated swing';\r\n                    break;\r\n                    case 1:\r\n                        this['animate_1'] = 'animated shake';\r\n                    break;\r\n                    case 2:\r\n                        this['animate_2'] = 'animated tada';\r\n                    break;\r\n                    case 3:\r\n                        this['animate_3'] = 'animated heartBeat';\r\n                    break;\r\n                }\r\n            },\r\n            goChange(){\r\n                this.item_id = 'slide1';\r\n            }\r\n        }\r\n    }\r\n</script>\r\n\r\n<style lang=\"scss\">\r\n    @import '../../common/animate.css';\r\n    \r\n    .content {\r\n        text-align: center;\r\n        .content-swiper{\r\n            height: 100vh;\r\n            \r\n            image{\r\n                height: 200upx;\r\n                width: 200upx;\r\n                margin-top: 200upx;\r\n            }\r\n        }\r\n    }\r\n</style>首先 uni-app 支持sass。在css中直接引入了简洁版 animate.css 。 问题①之后通过查看文档，发现 circular 这个参数可以实现类似H5页面使用 swiper.js loop 参数的功能。这里我掉到了 uni-app 和 微信小程序 文档描述的坑中。因为一直在找 loop （循环）这个参数，我甚至都以为实现不了这个无限循环的功能了呢。原来 小程序 中这个参数叫做 circular （圆形）。o(╯□╰)o 问题③因为我这里要实现一个竖屏的滑动效果，所以将参数 vertical 设置为 true 。在 uni-app 中，通过 change 事件，可以监听每一个轮播屏的改变。在这个事件中，我记录的当前屏的下标 current 。然后将 非当前屏 的全部css3动画取消掉。最后在 animationfinish 事件中，当 swiper 滑动动画结束后，给当前屏的元素添加css3动画。 问题②在 uni-app 中有个 current-item-id 参数，代表当前所在滑块的 item-id 。这个文档我看了好久，才明白。原来是需要在 swiper-item 中指定上 item-id 。然后当用户点击事件触发时，修改绑定到 current-item-id 上的值即可。我的代码初始化时指定到了 item-id 为 slide2 这一屏上。 问题④最后一个问题时 uni-app 中隐藏掉H5导航栏。只需要在 pages.json 中设置 titleNView 为false 即可。我将代码托管到了 腾讯云开发者平台 ，需要的话可以参考。在代码目录 unpackage/dist/build/h5 中，就是生成好的H5版页面。需要注意的是，要部署到web服务器使用，不支持本地file协议打开。微信小程序代码<!--index.wxml-->\r\n<view class=\"container\">\r\n    <button bindtap='goChange'>跳转到</button>\r\n    <swiper vertical=\"true\" circular=\"true\" current=\"{{currentId}}\" indicator-dots=\"true\" bindchange=\"changeSwiper\" bindanimationfinish=\"changeFinish\">\r\n        <swiper-item>\r\n            <image src='../../static/uni.png' class='animated {{animate_0}}'></image>\r\n        </swiper-item>\r\n        <swiper-item>\r\n            <image src='../../static/uni.png' class='animated {{animate_1}}'></image>\r\n        </swiper-item>\r\n        <swiper-item>\r\n            <image src='../../static/uni.png' class='animated {{animate_2}}'></image>\r\n        </swiper-item>\r\n    </swiper>\r\n</view>\r\n//index.js\r\nconst app = getApp()\r\n\r\nPage({\r\n    data: {\r\n        currentId: 0,\r\n        animate_0: 'swing',\r\n        animate_1: '',\r\n        animate_2: ''\r\n    },\r\n    onLoad: function() {\r\n\r\n    },\r\n    goChange: function() {\r\n        this.setData({\r\n            currentId: 2\r\n        });\r\n    },\r\n    changeSwiper: function(event) {\r\n        let current = event.detail.current;\r\n        switch (current) {\r\n            case 0:\r\n                this.setData({\r\n                    animate_1: '',\r\n                    animate_2: ''\r\n                });\r\n                break;\r\n            case 1:\r\n                this.setData({\r\n                    animate_0: '',\r\n                    animate_2: ''\r\n                });\r\n                break;\r\n            case 2:\r\n                this.setData({\r\n                    animate_0: '',\r\n                    animate_1: ''\r\n                });\r\n                break;\r\n        }\r\n    },\r\n    changeFinish: function(event) {\r\n        let current = event.detail.current;\r\n        switch (current) {\r\n            case 0:\r\n                this.setData({\r\n                    animate_0: 'swing',\r\n                });\r\n                break;\r\n            case 1:\r\n                this.setData({\r\n                    animate_1: 'shake',\r\n                });\r\n                break;\r\n            case 2:\r\n                this.setData({\r\n                    animate_2: 'tada',\r\n                });\r\n                break;\r\n        }\r\n    }\r\n})", "title": "小程序swiper轮播CSS3动画及跳转到指定swiper-item实现思路 ", "shijian": "2019-6-3 00:08"}
